generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  fullName    String
  email       String  @unique
  phoneNumber String
  address     String?
  speciality  String?


  role         UserRole
  password     String
  profileImage String?

  userStatus UserStatus @default(ACTIVE)
  isDeleted  Boolean    @default(false)

  otp           Int?
  otpExpiry     DateTime?
  emailVerified Boolean   @default(false)

  //push notification
  fcmToken    String?
  shifAlert   Boolean @default(true)
  emailUpdate Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Shift        Shift[]
  BookShift    BookShift[]
  AssignWorker AssignWorker[]
  Documnet     Document[]
}

model Document {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String   @db.ObjectId
  name        String?
  documentUrl String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
}

model Shift {
  id          String        @id @default(auto()) @map("_id") @db.ObjectId
  userId      String        @db.ObjectId
  role        String
  location    String
  date        DateTime
  startTime   String
  endTime     String
  payAmount   Float
  vacancy     Int           @default(1)
  description String
  isUrgent    Boolean       @default(false)
  status      BookingStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  //relation
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  BookShift BookShift[]

  @@index([role, location])
}

model BookShift {
  id      String        @id @default(auto()) @map("_id") @db.ObjectId
  userId  String        @db.ObjectId
  shiftId String        @db.ObjectId
  status  BookingStatus @default(APPLIED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  //relation
  shift        Shift          @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  worker       User?          @relation(fields: [userId], references: [id], onDelete: Cascade)
  AssignWorker AssignWorker[]

  @@unique([shiftId, userId])
}

model AssignWorker {
  id            String        @id @default(auto()) @map("_id") @db.ObjectId
  organizerId   String        @db.ObjectId
  bookShiftId   String        @unique @db.ObjectId
  paymentStatus PaymentStatus @default(UNPAID)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  //relation
  organizer User?     @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  bookShift BookShift @relation(fields: [bookShiftId], references: [id], onDelete: Cascade)
}

model Contact {
  id      String @id @default(auto()) @map("_id") @db.ObjectId
  name    String
  email   String
  subject String
  message String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Payment {
  id            String        @id @default(auto()) @map("_id") @db.ObjectId
  workerId      String        @db.ObjectId
  bookShiftId   String        @db.ObjectId
  amount        Float
  status        PaymentStatus @default(UNPAID)
  paymentDate   DateTime?
  transactionId String?

  // Relationship fields
  // bookShift           Shift          @relation(fields: [bookShiftId], references: [id])
  // worker          User           @relation(fields: [workerId], references: [id])
}

enum UserRole {
  ADMIN
  SUPER_ADMIN
  USER
  ORGANIZER
}

enum UserStatus {
  PENDING
  ACTIVE
  BLOCKED
}

enum NotificationType {
  ORDER
  PAYMENT
  BOOKING
}

enum BookingStatus {
  PENDING
  APPLIED
  ASSIGNED
  COMPLETED // The shift has been worked and is finished.
  REJECTED
}

enum PaymentStatus {
  UNPAID
  PAID
  PENDING
  FAILED
  REFUNDED
}
